#include<armadillo>
#include "K-Means V2.cpp"
#include<iostream>

////////////////////////////////////////////
/// Vectorise matrix segments from a picture
arma::Mat<double> stripMatrix(const std::string imagePath, const arma::Col<int> segShape)
{
/*
imagePath       = Location of the image
segShape        = Shape of the segments to be extracted
*/

    ///Varibales
    arma::Mat<double> segMatrix; // Matrix containing segment vectors
    arma::Mat<double> imgMatrix;  // Image matrix

    ///Initalise Variables
    imgMatrix.load(imagePath, arma::pgm_binary);

    /// Strip segments from matrix
    for(int i = 0; i < floor(imgMatrix.n_rows/segShape(0)); i++ )
    {
        for(int j = 0; j < floor(imgMatrix.n_cols/segShape(1)); j++)
        {
            // Strip submatricies and append them
            segMatrix = arma::join_rows(segMatrix, arma::vectorise(imgMatrix.submat(i*segShape(0), j*segShape(1), i*segShape(0) + segShape(0) - 1,  j*segShape(1) + segShape(1) - 1)));
        }
    }

    return segMatrix;
}

//////////////////////////////////////////////////////////////
/// Create training data and obtain a dictionary using K-Means
arma::Mat<double> getDict(const arma::uword pics, const arma::Col<int> segShape, const arma::uword nCent, const arma::uword nIter)
{
/*
pics            = Number of pictures
segShape        = Shape of the segments to be extracted
nCnet           = Number of centroids
nIter           = Number of iterations
*/
    /// Variables
    arma::Mat<double> centData; // Marix to hold centroids
    arma::Mat<double> trainingData; // Create Centroids


    ///Create training data
    for(int i = 1; i <= pics; i++)
    {
        std::string imagePath = std::string("Cat Pictures/cat_test") + std::to_string(i) + ".pgm";
        trainingData = arma::join_horiz(trainingData, stripMatrix(imagePath, segShape));
    }

    ///Create centroids
    centData = initCent(nCent, trainingData);

    // Iterate through the K-Means algorithm to find convergance
    for(int i = 0;  i < nIter; i++)
    {
        centData = recalCentroid(trainingData, centData);
    }

    trainingData.save("Cluster Data/data", arma::csv_ascii);
    centData.save("Cluster Data/centroids", arma::csv_ascii);
    return centData;
}

////////////////////////////////////////////////////////
/// Obtain a fake dictionary to test accuracy of K-Means
arma::Mat<double> fakeDict(const arma::uword pics, const arma::Col<int> segShape, const arma::uword nCent, const arma::uword nIter)
{
/*
pics            = Number of pictures
segShape        = Shape of the segments to be extracted
nCnet           = Number of centroids
nIter           = Number of iterations
*/
    /// Variables
    arma::Mat<double> centData; // Marix to hold  fake centroids
    arma::Mat<double> trainingData; // Create Centroids
    arma::Mat<double> centRanges; // Matrix to the min-max value for all the dimension of a centroid

    /// Temporary Varibales
    //arma::Row<int> randCentDim; // Vector to store fake centroids

    ///Create training data
    for(int i = 1; i <= pics; i++)
    {
        std::string imagePath = std::string("Cat Pictures/cat_test") + std::to_string(i) + ".pgm";
        trainingData = arma::join_horiz(trainingData, stripMatrix(imagePath, segShape));
    }

    ///Create ranges for centroids dimensions
    //Obtain ranges for each dimension
    centRanges = arma::join_horiz(centRanges,arma::min(trainingData, 1));
    centRanges = arma::join_horiz(centRanges,arma::max(trainingData, 1));

    /// Generate fake centroids
    //Centroids are generated by centroids

    for(int i = 0; i < trainingData.n_rows; i++)
    {
        arma::Row<double> randCentDim = arma::randi<arma::Row<double>>(nCent, arma::distr_param(centRanges(i,0),centRanges(i,1))); // Generate ith dimension of each centroid
        centData = arma::join_cols(centData, randCentDim);
    }


    return centData;
}

///////////////
/// GMM K-Means
arma::Mat<double> gmmDict(const arma::uword pics, const arma::Col<int> segShape, const arma::uword nCent, const arma::uword nIter)
{
/*
pics            = Number of pictures
segShape        = Shape of the segments to be extracted
nCnet           = Number of centroids
nIter           = Number of iterations
*/
    /// Variables
    arma::Mat<double> centData; // Marix to hold centroids
    arma::Mat<double> trainingData; // Create Centroids


    ///Create training data
    for(int i = 1; i <= pics; i++)
    {
        std::string imagePath = std::string("Cat Pictures/cat_test") + std::to_string(i) + ".pgm";
        trainingData = arma::join_horiz(trainingData, stripMatrix(imagePath, segShape));
    }

    arma::gmm_diag model;
    model.learn(trainingData, nCent, arma::maha_dist, arma::random_subset, nIter, 0, 0,  true);

    model.means.save("Cluster Data/gmmMeans", arma::csv_ascii);
    return model.means;
}

///////////////////////////////////
/// Compress Image using dictionary
double compImage(const arma::Mat<double>& fullImage, const arma::Mat<double>& dict, const arma::Col<int> segShape )
{
/*
fullImage       = Image to be compressed
dict            = Dictionary of centroids
segShape        = Shape of the segments to be extracted
*/
    ///Variables
    arma::Mat<double> compImage {fullImage}; // Compressed Image
    arma::Col<double> segVec;    // Vector to hold segments extracted from the full image
    double distortion {0};

    /// Temp Variables
    double temp_distance {0};
    double min_distance {0};
    arma::uword min_position {0};

    /// Strip segments from matrix
    for(int i = 0; i < floor(fullImage.n_rows/segShape(0)); i++ )
    {
        for(int j = 0; j < floor(fullImage.n_cols/segShape(1)); j++)
        {
            // Strip submatricies and append them
            segVec = arma::vectorise(fullImage.submat(i*segShape(0), j*segShape(1), i*segShape(0) + segShape(0) - 1,  j*segShape(1) + segShape(1) - 1));

            /// Find the closest
            temp_distance = arma::norm(segVec - dict.col(0));
            min_distance = temp_distance;
            min_position = 0;

            for(int k = 1; k < dict.n_cols; k++)
            {
                temp_distance = arma::norm(segVec - dict.col(k));
                if (temp_distance < min_distance)
                {
                min_distance = temp_distance;
                min_position = k;
                }
            }

            /// Compress the image segment using the dictionary
            compImage.submat(i*segShape(0), j*segShape(1), i*segShape(0) + segShape(0) - 1,  j*segShape(1) + segShape(1) - 1) = arma::reshape(dict.col(min_position), segShape(0), segShape(1));
            distortion += min_distance;
        }


    }

    //compImage.save("Cat Pictures/compressedImage.pgm", arma::pgm_binary);
    return distortion;
}


int main()
{
    ///Settings
    arma::arma_rng::set_seed_random();

    ///Constants
    const arma::uword pics = 4;
    const arma::uword nCent = 16;
    const arma::uword nIter = 5;
    const arma::Col<int> segShape = {4, 4};

    ///Varibales
    arma::Mat<double> fullImage;
    fullImage.load("Cat Pictures/cat.pgm", arma::pgm_binary); // Load full image

    arma::Mat<double> kmDictionary = getDict(pics, segShape, nCent, nIter); // K-Means dictionary
    arma::Mat<double> gmDictionary = gmmDict(pics, segShape, nCent, nIter);
    arma::Mat<double> kmFakeDictionary = fakeDict(pics, segShape, nCent, nIter); // Fake K-Means dictionary
    arma::Mat<double> distortion(4,16,arma::fill::zeros);

    /// Compress Image
    //compImage(fullImage, kmDictionary, segShape);
    //compImage(fullImage, kmFakeDictionary, segShape);
    //compImage(fullImage, gmDictionary, segShape);


    for(int i = 0; i < 16; i++)
    {
        kmDictionary = getDict(pics, segShape, (i+1)*2, nIter); // K-Means dictionary
        kmFakeDictionary = fakeDict(pics, segShape, (i+1)*2, nIter); // Fake K-Means dictionary
        gmDictionary = gmmDict(pics, segShape, (i+1)*2, nIter); // K-Means dictionary from arma::gmm

        distortion(0,i) = (i+1)*2;
        distortion(1,i) = compImage(fullImage, kmDictionary, segShape);
        distortion(2,i) = compImage(fullImage, kmFakeDictionary, segShape);
        distortion(3,i) = compImage(fullImage, gmDictionary, segShape);

    }

    distortion.save("Cluster Data/distortion", arma::csv_ascii);

}
